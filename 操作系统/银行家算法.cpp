#include <stdio.h>

#define True 1
#define False 0

int M = 5; 	// 进程数 
int N = 3; 	// 资源数

char Name[3] = {'a', 'b', 'c'};		// 资源的名称
int Max[5][3] = {{7, 5, 3}, {3, 2, 2}, {9, 0, 2}, {2, 2, 2}, {4, 3, 3}};		// 最大需求矩阵
int Allocation[5][3] = {{0, 1, 0}, {2, 0, 0}, {3, 0, 2}, {2, 1, 1}, {0, 0, 2}}; // 系统已分配矩阵
int Need[5][3] = {0};				// 还需要资源矩阵
int Available[3] = {10, 5, 7};		// 可用资源矩阵
int Request[3] = {0};				// 请求资源向量
int Work[3] = {0};					// 存放系统可提供资源量
int Finish[5] = {0};				// 标记系统是否有足够的资源分配给各个进程
int Security[5] = {0};				// 存放安全序列

/*******************************************************************************/ 
/*******************************************************************************/ 

void init(); 		// 初始化数据函数（计算 Need[][]，计算 Available[]） 
void show();		// 安全性算法函数 
int safe();			// 安全性算法函数 
void bank();		// 行家算法函数（对申请资源进行试分配） 
void test(int i);	// 试探性分配资源函数（试探性的将资源分配给第 i 个进程） 
void retest(int i);	// 试探性分配资源作废函数（与 test() 操作相反） 

/*******************************************************************************/ 
/*******************************************************************************/ 

// 主函数
int main() 
{
	printf("---------------------------------------------------\n");
	printf("||                                               ||\n");
	printf("||                  银行家算法                   ||\n");
	printf("||                                               ||\n");
	printf("---------------------------------------------------\n");
	
	// 初始化数据
	init();
		
	// 显示各种资源
	show();
	
	// 用安全性算法判定系统当前时刻是否安全，不安全就不再继续分配资源
	// 安全时：safe() 返回 True；不安全时：safe() 返回 False 
	if (!safe())
	{ 
		return 0;
	}
 
	while (1)
	{
		int flag;
		printf("\n***************************************************\n");
		printf("***************************************************\n\n");
		printf("---------------------------------------------------\n");
		printf("||                                               ||\n");
		printf("||                请求分配：输入 1               ||\n");
		printf("||                退出分配：输入 0               ||\n");
		printf("||                                               ||\n");
		printf("---------------------------------------------------\n");
		printf("请选择：");
		scanf("%d", &flag);
		switch (flag)
		{
			case 1:
				bank();
				break;
			case 0:
				return 0;
			default:
				printf("选择出错，请再次选择!\n");
				break;
		}
	}
}

/*******************************************************************************/ 
/*******************************************************************************/ 

// 初始化数据函数（计算 Need[][]，计算 Available[]） 
void init()
{
	// already[] 用于统计已经分配的资源
	int already[3] = {0};

	for (int i = 0; i < M; i++)
	{
		for (int j = 0; j < N; j++)
		{
			// 还需要资源 = 最大需求资源 - 已分配资源 
			Need[i][j] = Max[i][j] - Allocation[i][j];
			// 累加得到已经分配的资源（即：对 Allocation 进行列累加） 
			already[j] += Allocation[i][j];
		}
	}

	// 求 Available[]（系统中可利用的资源量） 
	for (int i = 0; i < N; i++)
	{ 
		// 现在的可用资源 = 一开始的可用资源 - 已经分配的资源 
		Available[i] = Available[i] - already[i];
	} 
}

/*******************************************************************************/ 
/*******************************************************************************/ 

// 安全性算法函数 
void show()
{
	// 输出 Available[]
	printf("\n系统目前的可用资源【Available】：\n");
	printf("                     ");
	for (int i = 0; i < N; i++)
	{ 
		printf("%c  ", Name[i]);
	} 
	printf("\n");
	printf("                     ");
	for (int i = 0; i < N; i++) 
	{
		printf("%d  ", Available[i]);
	}
	printf("\n");
	
	// 输出 Max[][]、Allocation[][]、Need[][] 
	printf("\n系统当前的资源分配情况如下：\n\n");
	printf("          【Max】     【Allocation】   【Need】\n");
	// 输出资源名
	printf("          ");
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < N; j++)
		{
			printf("%c  ", Name[j]);
		}
		printf("      ");
	}
	printf("\n\n");
	
	// 输出每个进程的 Max、Allocation、Need
	for (int i = 0; i < M; i++)
	{
		printf(" 【P%d】   ", i);
		for (int j = 0; j < N; j++)
		{ 
			printf("%d  ", Max[i][j]);
		} 
		printf("      ");
		for (int j = 0; j < N; j++)
		{ 
			printf("%d  ", Allocation[i][j]);
		} 
		printf("      ");
		for (int j = 0; j < N; j++)
		{ 
			printf("%d  ", Need[i][j]);
		} 
		printf("\n");
	}
}

/*******************************************************************************/ 
/*******************************************************************************/ 

// 安全性算法函数 
int safe()
{
	int x = 0, apply;
	
	// 初始化 work
	for (int i = 0; i < N; i++)
	{ 
		Work[i] = Available[i];
	}
	 
	// 初始化 Finish
	for (int i = 0; i < M; i++)
	{ 
		Finish[i] = False;
	}
	 
	// 求安全序列
	for (int i = 0; i < M; i++)
	{
		apply = 0;
		for (int j = 0; j < N; j++)
		{
			// 当该进程还未解决且该进程的需求量小于可提供量时执行 
			if (Finish[i] == False && Need[i][j] <= Work[j])
			{
				apply++;
				// 直到某个进程的每类资源需求数都小于系统可用资源数才可分配
				if (apply == N)
				{
					for (int k = 0; k < N; k++)
					{ 
						// 将资源分配给 Need 
						// 当前可分配资源 = 原来可分配资源 - 需求资源 
						Work[k] = Work[k] - Need[i][k]; 
						
						// 再次更新当前可分配资源
						// 当前可分配资源 = 原来可分配资源 + 已解决进程的最大需求资源 
						Work[k] = Work[k] + Max[i][k]; 
					}
					
					// 分配完一个进程后就将该进程对应的 Finish 设为 True 
					Finish[i] = True;
					// 记录安全序列 
					Security[x++] = i;
					// 保证每次查询均从第一个进程开始
					i = -1; 
				}
			}
		}
	}

	// 只要 Finish 中有一个 False，那么就是不安全的 
	for (int i = 0; i < M; i++)
	{
		if (Finish[i] == False)
		{
			printf("\n【系统不安全，请重新分配！】\n");
			return False;
		}
	} 
	
	// 如果 Finish 中全为 True，那么就是安全的 
	printf("\n【系统是安全的!】\n");
	printf("存在一个安全序列：");
	for (int i = 0; i < M; i++)
	{
		printf("【P%d】 ", Security[i]);
	}
	printf("\n");
	return True;
}

/*******************************************************************************/ 
/*******************************************************************************/ 

// 行家算法函数（对申请资源进行试分配） 
void bank()
{
	// 标志变量，判断能否进入银行家算法的下一步
	int flag = True;
	int i; 

	printf("\n请输入请求分配资源的进程号【0-%d】：", M - 1);
	scanf("%d", &i);

	printf("\n请输入进程 P%d 要申请的资源个数：\n", i);
	for (int j = 0; j < N; j++)
	{
		printf("%c ", Name[j]);
	}
	printf("\n");
	for (int j = 0; j < N; j++)
	{
		scanf("%d", &Request[j]);
	}

	// 判断银行家算法的两个前提条件是否成立
	for (int j = 0; j < N; j++)
	{
		// 判断申请资源是否大于需求资源，若大于则出错
		if (Request[j] > Need[i][j]) 
		{
			printf("\n进程 P%d 申请的资源大于它需要的资源\n", i);
			printf("【分配不合理，不予分配！】\n");
			flag = False;
			break;
		}
		else
		{
			// 判断申请资源是否大于当前可分配资源，若大于则出错
			if (Request[j] > Available[j])
			{
				printf("\n进程 P%d 申请的资源大于系统现在可利用的资源\n", i);
				printf("【系统尚无足够资源，不予分配！】\n");
				flag = False;
				break;
			}
		}
	}
	
	// 若前两个条件均成立，则试分配资源，寻找安全序列
	if (flag)
	{
		test(i);		// 根据进程需求量,试分配资源
		show();	 		// 根据进程需求量，显示试分配后的资源量
		if (!safe()) 	// 寻找安全序列
		{
			// 如果试分配后发现不存在安全序列，那么就撤回此分配（还原操作） 
			retest(i);
			show();
		}
	}
}

/*******************************************************************************/ 
/*******************************************************************************/ 

// 试探性分配资源函数（试探性的将资源分配给第 i 个进程） 
void test(int i)
{
	for (int j = 0; j < N; j++)
	{
		// 现在的可用资源数 = 原来的可用资源数 - 被请求资源数 
		Available[j] = Available[j] - Request[j];
		// 现在已经分配的资源数 = 原来已经分配的资源数 + 被请求资源数  
		Allocation[i][j] = Allocation[i][j] + Request[j];
		// 现在需要的资源数 = 原来需要的资源数 - 被请求资源数 
		Need[i][j] = Need[i][j] - Request[j];
	}
}

/*******************************************************************************/ 
/*******************************************************************************/ 

// 试探性分配资源作废函数（与 test() 操作相反） 
void retest(int i)
{
	for (int j = 0; j < N; j++)
	{
		// 以下代码的作用在于对 test() 操作进行一个逆向的还原 
		Available[j] = Available[j] + Request[j];
		Allocation[i][j] = Allocation[i][j] - Request[j];
		Need[i][j] = Need[i][j] + Request[j];
	}
}



/* 案例 */ 
/********************************************************************************

---------------------------------------------------
||                                               ||
||                  银行家算法                   ||
||                                               ||
---------------------------------------------------

系统目前的可用资源【Available】：
                     a  b  c
                     3  3  2

系统当前的资源分配情况如下：

          【Max】     【Allocation】   【Need】
          a  b  c        a  b  c        a  b  c

 【P0】   7  5  3        0  1  0        7  4  3
 【P1】   3  2  2        2  0  0        1  2  2
 【P2】   9  0  2        3  0  2        6  0  0
 【P3】   2  2  2        2  1  1        0  1  1
 【P4】   4  3  3        0  0  2        4  3  1

【系统是安全的!】
存在一个安全序列：【P1】 【P3】 【P0】 【P2】 【P4】

---------------------------------------------------
||                                               ||
||                请求分配：输入 1               ||
||                退出分配：输入 0               ||
||                                               ||
---------------------------------------------------
请选择：1

请输入请求分配资源的进程号【0-4】：1

请输入进程 P1 要申请的资源个数：
a b c
1 0 2

系统目前的可用资源【Available】：
                     a  b  c
                     2  3  0

系统当前的资源分配情况如下：

          【Max】     【Allocation】   【Need】
          a  b  c        a  b  c        a  b  c

 【P0】   7  5  3        0  1  0        7  4  3
 【P1】   3  2  2        3  0  2        0  2  0
 【P2】   9  0  2        3  0  2        6  0  0
 【P3】   2  2  2        2  1  1        0  1  1
 【P4】   4  3  3        0  0  2        4  3  1

【系统是安全的!】
存在一个安全序列：【P1】 【P3】 【P0】 【P2】 【P4】

---------------------------------------------------
||                                               ||
||                请求分配：输入 1               ||
||                退出分配：输入 0               ||
||                                               ||
---------------------------------------------------
请选择：1

请输入请求分配资源的进程号【0-4】：4

请输入进程 P4 要申请的资源个数：
a b c
3 3 0

进程 P4 申请的资源大于系统现在可利用的资源
【系统尚无足够资源，不予分配！】

---------------------------------------------------
||                                               ||
||                请求分配：输入 1               ||
||                退出分配：输入 0               ||
||                                               ||
---------------------------------------------------
请选择：1

请输入请求分配资源的进程号【0-4】：0

请输入进程 P0 要申请的资源个数：
a b c
0 2 0

系统目前的可用资源【Available】：
                     a  b  c
                     2  1  0

系统当前的资源分配情况如下：

          【Max】     【Allocation】   【Need】
          a  b  c        a  b  c        a  b  c

 【P0】   7  5  3        0  3  0        7  2  3
 【P1】   3  2  2        3  0  2        0  2  0
 【P2】   9  0  2        3  0  2        6  0  0
 【P3】   2  2  2        2  1  1        0  1  1
 【P4】   4  3  3        0  0  2        4  3  1

【系统不安全，请重新分配！】

系统目前的可用资源【Available】：
                     a  b  c
                     2  3  0

系统当前的资源分配情况如下：

          【Max】     【Allocation】   【Need】
          a  b  c        a  b  c        a  b  c

 【P0】   7  5  3        0  1  0        7  4  3
 【P1】   3  2  2        3  0  2        0  2  0
 【P2】   9  0  2        3  0  2        6  0  0
 【P3】   2  2  2        2  1  1        0  1  1
 【P4】   4  3  3        0  0  2        4  3  1

---------------------------------------------------
||                                               ||
||                请求分配：输入 1               ||
||                退出分配：输入 0               ||
||                                               ||
---------------------------------------------------
请选择：0

--------------------------------
Process exited after 83.06 seconds with return value 0
请按任意键继续. . .

********************************************************************************/ 
