#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// 一个生产者，一个消费者
int main()
{
	int p, fd[2], n = 1;
	char buf[50], s[50];
	
	pipe(fd);	// 创建管道，以实现进程间的通讯
	
	// 0：创建子进程，从子进程返回的id值，大于0：从父进程返回的子进程id值，-1：创建失败
	while ((p = fork()) == -1);	// 创建子进程 p，创建不成功就一直创建
	
	while (n++ <= 3) {
		// 子进程执行段
		if (p == 0) {
			// int lockf(files, function, size)
			// files：文件描述符
			// function：是锁定和解锁（1表示锁定, 0表示解锁）
			// size：是锁定或解锁的字节数，若用0，表示从文件的当前位置到文件尾
			lockf(fd[1], 1, 0);		// 加锁锁定写入端
			sprintf(buf, "车门已关闭");	// 将 “车门已关闭” 写入 buf
			write(fd[1], buf, 50);		// 通过管道的写入端将 buf 写入
			sleep(3);			// 睡眠3秒，让父进程读
			lockf(fd[1], 0, 0);		// 释放管道写入端
			
			// 如果从管道读出端成功读到就将 buf 赋给 s
			read(fd[0], s, 50);
			// 验证 s 的内容，判断字符串相等
			if (strcmp(s, "汽车到站停车，打开车门") == 0) {
				printf("汽车已经到站停车，通知售票员可以打开车门\n");
				printf("%s\n", s);	// "汽车到站停车，打开车门"
				printf("乘客陆续上车……\n");
				printf("----------------------------------------\n");
			// 如果没有读到就执行此段程序
			}else {
				printf("汽车未到站，不可开门\n");
				printf("----------------------------------------\n");
			}
		// 父进程执行段
		}else {
			// 如果从管道读出端成功读到就将 buf 赋给 s
			read(fd[0], s, 50);
			// 验证 s 的内容，判断字符串相等
			if (strcmp(s, "车门已关闭") == 0) {
				printf("%s\n", s);	// "车门已关闭"
				printf("通知司机车门已经关闭，可以启动车辆\n");
				printf("司机启动车辆\n");
				printf("正常行车\n");
				printf("售票员车上售票\n");
				printf("----------------------------------------\n");
			// 如果没有读到就执行此段程序
			}else {
				printf("车门未关闭，不可以启动车辆\n");
				printf("----------------------------------------\n");
			}
			
			lockf(fd[1], 1, 0);			// 加锁锁定写入端
			sprintf(buf, "汽车到站停车，打开车门");	// 将 “汽车到站停车，打开车门” 写入 buf
			write(fd[1], buf, 50);			// 通过管道的写入端将 buf 写入
			sleep(3);				// 睡眠3秒，让父进程读
			lockf(fd[1], 0, 0);			// 释放管道写入端
		} // else
	} // while
}


