import Vue from 'vue';
import App from './App.vue';

Vue.config.productionTip = false;

/*
-------------------------------------------------------------------------------------------------------------------------------------------
    之前我们已经学习了三种组件间通信的方式，分别是：
        1、父组件 ===> 子组件：props
        2、子组件 ===> 父组件：父组件传递函数+props
        3、子组件 ===> 夫组件：组件自定义事件
    而对于，祖孙以及兄弟组件之间通信虽然也可以用上述方式实现，但是太麻烦，且不方便，阅读性太差！！！
    所以，Vue 社区的开发人员就找到了一种开发技巧可以解决祖孙及兄弟组件之间的通信问题，而这个技巧便是：全局事件总线！！！
    （注意：全局事件总线是众多开发者的经验性技巧，而并不是 Vue 官方提供的某个 API）

    那该如何解决祖孙及兄弟组件之间的通信问题呢？
        之前我们在使用 父组件传递函数+props 或 组件自定义事件 的时候，原理其实都是在子组件中调用父组件中的回调函数，而这对于父子之间其实是比较方便操作的，
        只不过对于祖孙及兄弟组件之间则需要多级转发或是各种逻辑绑定，导致实现较为复杂。所以，其实只要让彼此需要通信的两个组件间能直接通信，而不用依赖中间者转发或是不用依赖各种逻辑绑定，
        那么，任何组件之间的通信不就简化为了类似普通的父子组件通信的过程了吗？

    那该如何让任何两个组件之间都可以直接通信呢？
        设想，要是有一个中间人，它可以将任何彼此两个组件的通信连通起来不就好了！
        而这个 “中间人” 需要具备两个方面的能力：
            1、任何组件都要能看得见它
            2、它必须具备 $on、$emit、$off 三个方法
        对于第一个要求，我们初步可能会想到两个家伙具备所有组件都看得见这个条件：
            1、window
            2、VueComponent
            但是，一般我们不会在 window 上操作数据，所以只有 VueComponent
            又但是，VueComponent（组件实例对象 vc）是一个组件实例化之后才会出现的产物，我们不可能为了实现“中间人”而单独弄一个组件出来啊
            再说了，每个实例化的 vc 都是一个个彼此独立的 VueComponent，也并不满足其能让任何组件都看得见这个要求。
            此时，我们便要用到之前学习过的一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype
            即：让组件实例对象（vc）可以访问到 Vue 原型上的属性、方法
            并且，Vue.prototype 是唯一的！
            这下有办法了！那个中间人不就是 Vue.prototype 吗！所以组件的实例对象 vc 都能看得见它！
            比如，我们在 main.js 中：Vue.prototype.test = '牛逼'，那么所有的 vc 都能 this.test
            （先会在 vc 中找 test，找不到就会去 VueComponent.prototype 上找，再找不到就会到 VueComponent.prototype.__proto__ 即 Vue.prototype 上找）
        下面考虑第二个要求：
            首先，要知道的是：$on、$emit、$off 方法只在 vm 和 vc 上拥有，而 vm 和 vc 上的这三个方法都是来自于 VueComponent
            所以，Vue.prototype.test 并没有 $on、$emit、$off 方法
            解决办法是，我们可以自己 new 一个 vc 出来，然后赋值给 Vue.prototype.test
                const Demo = Vue.extend({});
                const d = new Demo();
                Vue.prototype.test = d;
            以上办法固然可以，但是既然 vm 也具有 $on、$emit、$off，那干脆直接把 vm 赋值给 Vue.prototype.test，何必再多弄一个 vc 出来呢
            但是，const vm = new Vue({...}) 是在模板都已经解析后才赋值 vm 的，那个时候再来 Vue.prototype.test = vm 已经晚了
            所以，此时不得不借助一个生命周期钩子 beforeCreate，该钩子执行时 Vue 实例对象已经形成了（就是 this），并且模板还没有解析，甚至数据代理与数据监测都还没有完成，此时就是最佳时机：
                new Vue({
                    el: '#app',
                    render: h => h(App),
                    beforeCreate() {
                        // 安装全局事件总线，this 就是当前应用的 vm，所以 $bus 也就是 vm
                        Vue.prototype.$bus = this;  // 此处我们遵守 vue 的自带函数命名规范，直接命名为 $bus，更符合语义
                    },
                })
            以上就是全局事件总线的实现原理！！！

            推荐今后组件的通信请遵循以下原则：
                1、父组件 ===> 子组件：props
                2、子组件 ===> 夫组件：组件自定义事件
                3、祖孙或兄弟组件：全局事件总线
-------------------------------------------------------------------------------------------------------------------------------------------
 */

new Vue({
    el: '#app',
    render: h => h(App),
    beforeCreate() {
        Vue.prototype.$bus = this;
    },
})